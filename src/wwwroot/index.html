<!DOCTYPE html>
<html green lang="en">
<head prefix="og: http://ogp.me/ns#">
    <meta charset="utf-8">

    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="manifest" href="/icons/site.webmanifest">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#000000">
    <link rel="shortcut icon" href="/icons/favicon.ico">
    <meta name="apple-mobile-web-app-title" content="TorrentKontrol">
    <meta name="application-name" content="TorrentKontrol">
    <meta name="theme-color" content="#000000">

    <title>TorrentKontrol</title>
    <meta name="description" content="TorrentKontrol by Conesoft">
    <meta property="og:type" content="website">
    <meta property="og:title" content="TorrentKontrol">
    <meta property="og:description" content="TorrentKontrol by Conesoft">
    <meta property="og:image" content="/meta-image.jpg">

    <meta name="viewport" content="width=device-width">
    <base href="~/">
    <link rel="stylesheet" type="text/css" href="https://cdn.conesoft.net/style.css?v=23270f96955b32cfbdca1965a6e939d8">
    <link rel="stylesheet" type="text/css" href="/style.css?v=51fdfd41">
    <script>/* humanize.min.js - v1.8.2 */ "use strict"; var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (n) { return typeof n } : function (n) { return n && "function" == typeof Symbol && n.constructor === Symbol ? "symbol" : typeof n }; !function (n, e) { "object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], function () { return n.Humanize = e() }) : n.Humanize = e() }(this, function () { var n = [{ name: "second", value: 1e3 }, { name: "minute", value: 6e4 }, { name: "hour", value: 36e5 }, { name: "day", value: 864e5 }, { name: "week", value: 6048e5 }], e = { P: Math.pow(2, 50), T: Math.pow(2, 40), G: Math.pow(2, 30), M: Math.pow(2, 20) }, t = function (n) { return "undefined" != typeof n && null !== n }, r = function (n) { return n !== n }, i = function (n) { return isFinite(n) && !r(parseFloat(n)) }, o = function (n) { var e = Object.prototype.toString.call(n); return "[object Array]" === e }, a = { intword: function (n, e) { var t = arguments.length <= 2 || void 0 === arguments[2] ? 2 : arguments[2]; return a.compactInteger(n, t) }, compactInteger: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1]; e = Math.max(e, 0); var t = parseInt(n, 10), r = 0 > t ? "-" : "", i = Math.abs(t), o = String(i), a = o.length, u = [13, 10, 7, 4], l = ["T", "B", "M", "k"]; if (1e3 > i) return "" + r + o; if (a > u[0] + 3) return t.toExponential(e).replace("e+", "x10^"); for (var f = void 0, c = 0; c < u.length; c++) { var v = u[c]; if (a >= v) { f = v; break } } var s = a - f + 1, d = o.split(""), p = d.slice(0, s), h = d.slice(s, s + e + 1), g = p.join(""), m = h.join(""); m.length < e && (m += "" + Array(e - m.length + 1).join("0")); var b = void 0; if (0 === e) b = "" + r + g + l[u.indexOf(f)]; else { var y = Number(g + "." + m).toFixed(e); b = "" + r + y + l[u.indexOf(f)] } return b }, intComma: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1]; return a.formatNumber(n, e) }, intcomma: function () { return a.intComma.apply(a, arguments) }, fileSize: function (n) { var t = arguments.length <= 1 || void 0 === arguments[1] ? 2 : arguments[1]; for (var r in e) if (e.hasOwnProperty(r)) { var i = e[r]; if (n >= i) return a.formatNumber(n / i, t, "") + " " + r + "B" } return n >= 1024 ? a.formatNumber(n / 1024, 0) + " KB" : a.formatNumber(n, 0) + a.pluralize(n, " byte") }, filesize: function () { return a.fileSize.apply(a, arguments) }, formatNumber: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1], t = arguments.length <= 2 || void 0 === arguments[2] ? "," : arguments[2], r = arguments.length <= 3 || void 0 === arguments[3] ? "." : arguments[3], i = function (n, e, t) { return t ? n.substr(0, t) + e : "" }, o = function (n, e, t) { return n.substr(t).replace(/(\d{3})(?=\d)/g, "$1" + e) }, u = function (n, e, t) { return t ? e + a.toFixed(Math.abs(n), t).split(".")[1] : "" }, l = a.normalizePrecision(e), f = 0 > n && "-" || "", c = String(parseInt(a.toFixed(Math.abs(n || 0), l), 10)), v = c.length > 3 ? c.length % 3 : 0; return f + i(c, t, v) + o(c, t, v) + u(n, r, l) }, toFixed: function (n, e) { e = t(e) ? e : a.normalizePrecision(e, 0); var r = Math.pow(10, e); return (Math.round(n * r) / r).toFixed(e) }, normalizePrecision: function (n, e) { return n = Math.round(Math.abs(n)), r(n) ? e : n }, ordinal: function (n) { var e = parseInt(n, 10); if (0 === e) return n; var t = e % 100; if ([11, 12, 13].indexOf(t) >= 0) return e + "th"; var r = e % 10, i = void 0; switch (r) { case 1: i = "st"; break; case 2: i = "nd"; break; case 3: i = "rd"; break; default: i = "th" }return "" + e + i }, times: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1]; if (i(n) && n >= 0) { var r = parseFloat(n), o = ["never", "once", "twice"]; if (t(e[r])) return String(e[r]); var a = t(o[r]) && o[r].toString(); return a || r.toString() + " times" } return null }, pluralize: function (n, e, r) { return t(n) && t(e) ? (r = t(r) ? r : e + "s", 1 === parseInt(n, 10) ? e : r) : null }, truncate: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 100 : arguments[1], t = arguments.length <= 2 || void 0 === arguments[2] ? "..." : arguments[2]; return n.length > e ? n.substring(0, e - t.length) + t : n }, truncateWords: function (n, e) { for (var r = n.split(" "), i = "", o = 0; e > o;)t(r[o]) && (i += r[o] + " "), o++; return r.length > e ? i + "..." : null }, truncatewords: function () { return a.truncateWords.apply(a, arguments) }, boundedNumber: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 100 : arguments[1], t = arguments.length <= 2 || void 0 === arguments[2] ? "+" : arguments[2], r = void 0; return i(n) && i(e) && n > e && (r = e + t), (r || n).toString() }, truncatenumber: function () { return a.boundedNumber.apply(a, arguments) }, oxford: function (n, e, r) { var i = n.length, o = void 0; if (2 > i) return String(n); if (2 === i) return n.join(" and "); if (t(e) && i > e) { var u = i - e; o = e, r = t(r) ? r : ", and " + u + " " + a.pluralize(u, "other") } else o = -1, r = ", and " + n[i - 1]; return n.slice(0, o).join(", ") + r }, dictionary: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? " is " : arguments[1], r = arguments.length <= 2 || void 0 === arguments[2] ? ", " : arguments[2], i = ""; if (t(n) && "object" === ("undefined" == typeof n ? "undefined" : _typeof(n)) && !o(n)) { var a = []; for (var u in n) if (n.hasOwnProperty(u)) { var l = n[u]; a.push("" + u + e + l) } return a.join(r) } return i }, frequency: function (n, e) { if (!o(n)) return null; var t = n.length, r = a.times(t); return 0 === t ? r + " " + e : e + " " + r }, pace: function (e, t) { var r = arguments.length <= 2 || void 0 === arguments[2] ? "time" : arguments[2]; if (0 === e || 0 === t) return "No " + a.pluralize(0, r); for (var i = "Approximately", o = void 0, u = void 0, l = e / t, f = 0; f < n.length; ++f) { var c = n[f]; if (u = l * c.value, u > 1) { o = c.name; break } } o || (i = "Less than", u = 1, o = n[n.length - 1].name); var v = Math.round(u); return r = a.pluralize(v, r), i + " " + v + " " + r + " per " + o }, nl2br: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? "<br/>" : arguments[1]; return n.replace(/\n/g, e) }, br2nl: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? "\r\n" : arguments[1]; return n.replace(/\<br\s*\/?\>/g, e) }, capitalize: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1]; return "" + n.charAt(0).toUpperCase() + (e ? n.slice(1).toLowerCase() : n.slice(1)) }, capitalizeAll: function (n) { return n.replace(/(?:^|\s)\S/g, function (n) { return n.toUpperCase() }) }, titleCase: function (n) { var e = /\b(a|an|and|at|but|by|de|en|for|if|in|of|on|or|the|to|via|vs?\.?)\b/i, t = /\S+[A-Z]+\S*/, r = /\s+/, i = /-/, o = void 0; return (o = function (n) { for (var u = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1], l = arguments.length <= 2 || void 0 === arguments[2] ? !0 : arguments[2], f = [], c = n.split(u ? i : r), v = 0; v < c.length; ++v) { var s = c[v]; -1 === s.indexOf("-") ? !l || 0 !== v && v !== c.length - 1 ? t.test(s) ? f.push(s) : e.test(s) ? f.push(s.toLowerCase()) : f.push(a.capitalize(s)) : f.push(t.test(s) ? s : a.capitalize(s)) : f.push(o(s, !0, 0 === v || v === c.length - 1)) } return f.join(u ? "-" : " ") })(n) }, titlecase: function () { return a.titleCase.apply(a, arguments) } }; return a });</script>
    <script>/* morphdom.min.js */ "use strict"; var range, DOCUMENT_FRAGMENT_NODE = 11; function morphAttrs(e, t) { var n, r, o, a, i = t.attributes; if (t.nodeType !== DOCUMENT_FRAGMENT_NODE && e.nodeType !== DOCUMENT_FRAGMENT_NODE) { for (var d = i.length - 1; d >= 0; d--)r = (n = i[d]).name, o = n.namespaceURI, a = n.value, o ? (r = n.localName || r, e.getAttributeNS(o, r) !== a && ("xmlns" === n.prefix && (r = n.name), e.setAttributeNS(o, r, a))) : e.getAttribute(r) !== a && e.setAttribute(r, a); for (var l = e.attributes, c = l.length - 1; c >= 0; c--)r = (n = l[c]).name, (o = n.namespaceURI) ? (r = n.localName || r, t.hasAttributeNS(o, r) || e.removeAttributeNS(o, r)) : t.hasAttribute(r) || e.removeAttribute(r) } } var NS_XHTML = "http://www.w3.org/1999/xhtml", doc = "undefined" == typeof document ? void 0 : document, HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template"), HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange(); function createFragmentFromTemplate(e) { var t = doc.createElement("template"); return t.innerHTML = e, t.content.childNodes[0] } function createFragmentFromRange(e) { return range || (range = doc.createRange()).selectNode(doc.body), range.createContextualFragment(e).childNodes[0] } function createFragmentFromWrap(e) { var t = doc.createElement("body"); return t.innerHTML = e, t.childNodes[0] } function toElement(e) { return e = e.trim(), HAS_TEMPLATE_SUPPORT ? createFragmentFromTemplate(e) : HAS_RANGE_SUPPORT ? createFragmentFromRange(e) : createFragmentFromWrap(e) } function compareNodeNames(e, t) { var n, r, o = e.nodeName, a = t.nodeName; return o === a || (n = o.charCodeAt(0), r = a.charCodeAt(0), n <= 90 && r >= 97 ? o === a.toUpperCase() : r <= 90 && n >= 97 && a === o.toUpperCase()) } function createElementNS(e, t) { return t && t !== NS_XHTML ? doc.createElementNS(t, e) : doc.createElement(e) } function moveChildren(e, t) { for (var n = e.firstChild; n;) { var r = n.nextSibling; t.appendChild(n), n = r } return t } function syncBooleanAttrProp(e, t, n) { e[n] !== t[n] && (e[n] = t[n], e[n] ? e.setAttribute(n, "") : e.removeAttribute(n)) } var specialElHandlers = { OPTION: function (e, t) { var n = e.parentNode; if (n) { var r = n.nodeName.toUpperCase(); "OPTGROUP" === r && (r = (n = n.parentNode) && n.nodeName.toUpperCase()), "SELECT" !== r || n.hasAttribute("multiple") || (e.hasAttribute("selected") && !t.selected && (e.setAttribute("selected", "selected"), e.removeAttribute("selected")), n.selectedIndex = -1) } syncBooleanAttrProp(e, t, "selected") }, INPUT: function (e, t) { syncBooleanAttrProp(e, t, "checked"), syncBooleanAttrProp(e, t, "disabled"), e.value !== t.value && (e.value = t.value), t.hasAttribute("value") || e.removeAttribute("value") }, TEXTAREA: function (e, t) { var n = t.value; e.value !== n && (e.value = n); var r = e.firstChild; if (r) { var o = r.nodeValue; if (o == n || !n && o == e.placeholder) return; r.nodeValue = n } }, SELECT: function (e, t) { if (!t.hasAttribute("multiple")) { for (var n, r, o = -1, a = 0, i = e.firstChild; i;)if ("OPTGROUP" === (r = i.nodeName && i.nodeName.toUpperCase())) i = (n = i).firstChild; else { if ("OPTION" === r) { if (i.hasAttribute("selected")) { o = a; break } a++ } !(i = i.nextSibling) && n && (i = n.nextSibling, n = null) } e.selectedIndex = o } } }, ELEMENT_NODE = 1, DOCUMENT_FRAGMENT_NODE$1 = 11, TEXT_NODE = 3, COMMENT_NODE = 8; function noop() { } function defaultGetNodeKey(e) { if (e) return e.getAttribute && e.getAttribute("id") || e.id } function morphdomFactory(e) { return function (t, n, r) { if (r || (r = {}), "string" == typeof n) if ("#document" === t.nodeName || "HTML" === t.nodeName || "BODY" === t.nodeName) { var o = n; (n = doc.createElement("html")).innerHTML = o } else n = toElement(n); else n.nodeType === DOCUMENT_FRAGMENT_NODE$1 && (n = n.firstElementChild); var a = r.getNodeKey || defaultGetNodeKey, i = r.onBeforeNodeAdded || noop, d = r.onNodeAdded || noop, l = r.onBeforeElUpdated || noop, c = r.onElUpdated || noop, u = r.onBeforeNodeDiscarded || noop, N = r.onNodeDiscarded || noop, m = r.onBeforeElChildrenUpdated || noop, E = !0 === r.childrenOnly, f = Object.create(null), s = []; function p(e) { s.push(e) } function T(e, t) { if (e.nodeType === ELEMENT_NODE) for (var n = e.firstChild; n;) { var r = void 0; t && (r = a(n)) ? p(r) : (N(n), n.firstChild && T(n, t)), n = n.nextSibling } } function v(e, t, n) { !1 !== u(e) && (t && t.removeChild(e), N(e), T(e, n)) } function A(e) { d(e); for (var t = e.firstChild; t;) { var n = t.nextSibling, r = a(t); if (r) { var o = f[r]; o && compareNodeNames(t, o) ? (t.parentNode.replaceChild(o, t), h(o, t)) : A(t) } else A(t); t = n } } function h(t, n, r) { var o = a(n); if (o && delete f[o], !r) { if (!1 === l(t, n)) return; if (e(t, n), c(t), !1 === m(t, n)) return } "TEXTAREA" !== t.nodeName ? function (e, t) { var n, r, o, d, l, c = t.firstChild, u = e.firstChild; e: for (; c;) { for (d = c.nextSibling, n = a(c); u;) { if (o = u.nextSibling, c.isSameNode && c.isSameNode(u)) { c = d, u = o; continue e } r = a(u); var N = u.nodeType, m = void 0; if (N === c.nodeType && (N === ELEMENT_NODE ? (n ? n !== r && ((l = f[n]) ? o === l ? m = !1 : (e.insertBefore(l, u), r ? p(r) : v(u, e, !0), u = l) : m = !1) : r && (m = !1), (m = !1 !== m && compareNodeNames(u, c)) && h(u, c)) : N !== TEXT_NODE && N != COMMENT_NODE || (m = !0, u.nodeValue !== c.nodeValue && (u.nodeValue = c.nodeValue))), m) { c = d, u = o; continue e } r ? p(r) : v(u, e, !0), u = o } if (n && (l = f[n]) && compareNodeNames(l, c)) e.appendChild(l), h(l, c); else { var E = i(c); !1 !== E && (E && (c = E), c.actualize && (c = c.actualize(e.ownerDocument || doc)), e.appendChild(c), A(c)) } c = d, u = o } !function (e, t, n) { for (; t;) { var r = t.nextSibling; (n = a(t)) ? p(n) : v(t, e, !0), t = r } }(e, u, r); var s = specialElHandlers[e.nodeName]; s && s(e, t) }(t, n) : specialElHandlers.TEXTAREA(t, n) } !function e(t) { if (t.nodeType === ELEMENT_NODE || t.nodeType === DOCUMENT_FRAGMENT_NODE$1) for (var n = t.firstChild; n;) { var r = a(n); r && (f[r] = n), e(n), n = n.nextSibling } }(t); var O = t, C = O.nodeType, b = n.nodeType; if (!E) if (C === ELEMENT_NODE) b === ELEMENT_NODE ? compareNodeNames(t, n) || (N(t), O = moveChildren(t, createElementNS(n.nodeName, n.namespaceURI))) : O = n; else if (C === TEXT_NODE || C === COMMENT_NODE) { if (b === C) return O.nodeValue !== n.nodeValue && (O.nodeValue = n.nodeValue), O; O = n } if (O === n) N(t); else { if (n.isSameNode && n.isSameNode(O)) return; if (h(O, n, E), s) for (var g = 0, _ = s.length; g < _; g++) { var M = f[s[g]]; M && v(M, M.parentNode, !1) } } return !E && O !== t && t.parentNode && (O.actualize && (O = O.actualize(t.ownerDocument || doc)), t.parentNode.replaceChild(O, t)), O } } var morphdom = morphdomFactory(morphAttrs);</script>
</head>
<body>
    <header>
        <nav>
            <a href="" class="active">⌂ torrentkontrol</a>
        </nav>
    </header>
    <main>
        <section style="grid-template-columns: 1fr 1fr; gap: 0;">
            <button onclick='addtorrent()'>add through magnet link</button>
            <button onclick='addtorrent()' disabled>add through torrent file [not yet supported]</button>
        </section>
        <section>
            <ul id="links" style="grid-template-columns: repeat(auto-fit, minmax(10rem, 1fr))"></ul>
        </section>
        <section>
            <ul id="torrents">
                <li>no torrents active</li>
            </ul>
        </section>
        <section>
            <ul id="files"></ul>
        </section>
    </main>
    <footer>
        <p>&copy; 2023</p>
        <p>written by <a href="https://davepermen.net">davepermen</a></p>
        <p>a <a href="https://conesoft.net">conesoft product</a> running on .NET 7</p>
    </footer>
    <script>
        const sleep = (delay, resolveValue) => new Promise((resolve) => {
            setTimeout(() => resolve(resolveValue), delay)
        })

        async function addmagnethandler() {
            try {
                await navigator.registerProtocolHandler('magnet', document.location.origin + '/addmagneturi?uri=%s', 'TorrentKontrol magnet:// linkhandler');
            } catch (e) {
                console.log('can\'t register magnet://')
            }
        }
        addmagnethandler()

        async function addtorrenthandler() {
            try {
                launchQueue.setConsumer(async parameters => {
                    for (const handle in parameters.files) {
                        const file = await handle.getFile()
                        await fetch('/addtorrentfile', { method: 'POST', body: file })
                    }
                });
            } catch (e) {
                console.log('can\'t register .torrent')
            }
        }
        addtorrenthandler()

        async function addtorrent() {
            await fetch('/addtorrent', {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'magnet': prompt('magnet link') })
            })
        }

        async function removetorrent(hash) {
            await fetch('/removetorrent', {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'hash': hash })
            })
        }

        async function updateList(id, mapping) {
            let list = await (await fetch('/' + id)).json()
            let html = list.map(mapping).map(entry => entry !== null ? '<li horizontal style="grid-template-columns: 1fr auto">' + entry + '</li>' : '').join('\n')
            var item = document.getElementById(id)
            if (html !== item.innerHTML) {
                var copy = item.cloneNode().outerHTML
                var startTag = copy.split('>')[0] + '>'
                var endTag = copy.slice(startTag.length)
                console.log("starttag: " + startTag)
                console.log("endtag: " + endTag)
                morphdom(item, startTag + html + endTag)
            }
        }

        async function updateTable(id, mapping) {
            let list = await (await fetch('/' + id)).json()
            let html = list.map(mapping).map(entry => entry !== null ? '<tr>' + entry + '</tr>' : '').join('\n')
            var item = document.getElementById(id)
            if (html !== item.innerHTML) {
                var copy = item.cloneNode().outerHTML
                var startTag = copy.split('>')[0] + '>'
                var endTag = copy.slice(startTag.length)
                console.log("starttag: " + startTag)
                console.log("endtag: " + endTag)
                morphdom(item, startTag + html + endTag)
            }
        }

        async function loop() {
            while (true) {
                let requests = [
                    updateList('torrents', torrent =>
                        (torrent.state.toLowerCase() !== 'stopping' && torrent.state.toLowerCase() !== 'stopped')
                            ?
                            `<section vertical>
                                        <b>${torrent.name}</b>
                                            ${(torrent.size == -1
                                ? `<aside>incoming transmission ...</aside>`
                                : `<aside>size: ${Humanize.fileSize(torrent.size)}, ${torrent.progress.toFixed(2)}%, speed: ${Humanize.fileSize(torrent.downloadSpeed)}/s ${torrent.state.toLowerCase()}</aside>
                                           <progress max='100' value=${torrent.progress}></progress>`
                            )}
                                    </section>
                                    <button onclick='removetorrent("${torrent.hash}")'>🗙</button>`
                            : null
                    ),

                    updateList('files', file => `<a href='https://files.conesoft.net/Downloads/Torrents/${file.fullname + file.extension}' target='_blank'>${file.name}</a></td><td green>${Humanize.fileSize(file.size)}`),
                    updateList('links', link => '<a href="https://' + link.url + '" target="_blank">' + link.name + '</a>'),

                    sleep(333)
                ]
                await Promise.all(requests)
            }
        }

        loop()
    </script>
</body>
</html>
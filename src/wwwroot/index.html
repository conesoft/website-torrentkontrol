<!DOCTYPE html>
<html green lang="en">
<head prefix="og: http://ogp.me/ns#">
    <meta charset="utf-8">

    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="manifest" href="/icons/site.webmanifest">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#000000">
    <link rel="shortcut icon" href="/icons/favicon.ico">
    <meta name="apple-mobile-web-app-title" content="TorrentKontrol">
    <meta name="application-name" content="TorrentKontrol">
    <meta name="theme-color" content="#000000">

    <title>TorrentKontrol</title>
    <meta name="description" content="TorrentKontrol by Conesoft">
    <meta property="og:type" content="website">
    <meta property="og:title" content="TorrentKontrol">
    <meta property="og:description" content="TorrentKontrol by Conesoft">
    <meta property="og:image" content="/meta-image.jpg">

    <meta name="viewport" content="width=device-width">
    <base href="~/">
    <link rel="stylesheet" type="text/css" href="https://cdn.conesoft.net/style.css?v=23270f96955b32cfbdca1965a6e939d8">
    <link rel="stylesheet" type="text/css" href="/style.css?v=51fdfd41">
    <script>/* humanize.min.js - v1.8.2 */ "use strict"; var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (n) { return typeof n } : function (n) { return n && "function" == typeof Symbol && n.constructor === Symbol ? "symbol" : typeof n }; !function (n, e) { "object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], function () { return n.Humanize = e() }) : n.Humanize = e() }(this, function () { var n = [{ name: "second", value: 1e3 }, { name: "minute", value: 6e4 }, { name: "hour", value: 36e5 }, { name: "day", value: 864e5 }, { name: "week", value: 6048e5 }], e = { P: Math.pow(2, 50), T: Math.pow(2, 40), G: Math.pow(2, 30), M: Math.pow(2, 20) }, t = function (n) { return "undefined" != typeof n && null !== n }, r = function (n) { return n !== n }, i = function (n) { return isFinite(n) && !r(parseFloat(n)) }, o = function (n) { var e = Object.prototype.toString.call(n); return "[object Array]" === e }, a = { intword: function (n, e) { var t = arguments.length <= 2 || void 0 === arguments[2] ? 2 : arguments[2]; return a.compactInteger(n, t) }, compactInteger: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1]; e = Math.max(e, 0); var t = parseInt(n, 10), r = 0 > t ? "-" : "", i = Math.abs(t), o = String(i), a = o.length, u = [13, 10, 7, 4], l = ["T", "B", "M", "k"]; if (1e3 > i) return "" + r + o; if (a > u[0] + 3) return t.toExponential(e).replace("e+", "x10^"); for (var f = void 0, c = 0; c < u.length; c++) { var v = u[c]; if (a >= v) { f = v; break } } var s = a - f + 1, d = o.split(""), p = d.slice(0, s), h = d.slice(s, s + e + 1), g = p.join(""), m = h.join(""); m.length < e && (m += "" + Array(e - m.length + 1).join("0")); var b = void 0; if (0 === e) b = "" + r + g + l[u.indexOf(f)]; else { var y = Number(g + "." + m).toFixed(e); b = "" + r + y + l[u.indexOf(f)] } return b }, intComma: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1]; return a.formatNumber(n, e) }, intcomma: function () { return a.intComma.apply(a, arguments) }, fileSize: function (n) { var t = arguments.length <= 1 || void 0 === arguments[1] ? 2 : arguments[1]; for (var r in e) if (e.hasOwnProperty(r)) { var i = e[r]; if (n >= i) return a.formatNumber(n / i, t, "") + " " + r + "B" } return n >= 1024 ? a.formatNumber(n / 1024, 0) + " KB" : a.formatNumber(n, 0) + a.pluralize(n, " byte") }, filesize: function () { return a.fileSize.apply(a, arguments) }, formatNumber: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1], t = arguments.length <= 2 || void 0 === arguments[2] ? "," : arguments[2], r = arguments.length <= 3 || void 0 === arguments[3] ? "." : arguments[3], i = function (n, e, t) { return t ? n.substr(0, t) + e : "" }, o = function (n, e, t) { return n.substr(t).replace(/(\d{3})(?=\d)/g, "$1" + e) }, u = function (n, e, t) { return t ? e + a.toFixed(Math.abs(n), t).split(".")[1] : "" }, l = a.normalizePrecision(e), f = 0 > n && "-" || "", c = String(parseInt(a.toFixed(Math.abs(n || 0), l), 10)), v = c.length > 3 ? c.length % 3 : 0; return f + i(c, t, v) + o(c, t, v) + u(n, r, l) }, toFixed: function (n, e) { e = t(e) ? e : a.normalizePrecision(e, 0); var r = Math.pow(10, e); return (Math.round(n * r) / r).toFixed(e) }, normalizePrecision: function (n, e) { return n = Math.round(Math.abs(n)), r(n) ? e : n }, ordinal: function (n) { var e = parseInt(n, 10); if (0 === e) return n; var t = e % 100; if ([11, 12, 13].indexOf(t) >= 0) return e + "th"; var r = e % 10, i = void 0; switch (r) { case 1: i = "st"; break; case 2: i = "nd"; break; case 3: i = "rd"; break; default: i = "th" }return "" + e + i }, times: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1]; if (i(n) && n >= 0) { var r = parseFloat(n), o = ["never", "once", "twice"]; if (t(e[r])) return String(e[r]); var a = t(o[r]) && o[r].toString(); return a || r.toString() + " times" } return null }, pluralize: function (n, e, r) { return t(n) && t(e) ? (r = t(r) ? r : e + "s", 1 === parseInt(n, 10) ? e : r) : null }, truncate: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 100 : arguments[1], t = arguments.length <= 2 || void 0 === arguments[2] ? "..." : arguments[2]; return n.length > e ? n.substring(0, e - t.length) + t : n }, truncateWords: function (n, e) { for (var r = n.split(" "), i = "", o = 0; e > o;)t(r[o]) && (i += r[o] + " "), o++; return r.length > e ? i + "..." : null }, truncatewords: function () { return a.truncateWords.apply(a, arguments) }, boundedNumber: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? 100 : arguments[1], t = arguments.length <= 2 || void 0 === arguments[2] ? "+" : arguments[2], r = void 0; return i(n) && i(e) && n > e && (r = e + t), (r || n).toString() }, truncatenumber: function () { return a.boundedNumber.apply(a, arguments) }, oxford: function (n, e, r) { var i = n.length, o = void 0; if (2 > i) return String(n); if (2 === i) return n.join(" and "); if (t(e) && i > e) { var u = i - e; o = e, r = t(r) ? r : ", and " + u + " " + a.pluralize(u, "other") } else o = -1, r = ", and " + n[i - 1]; return n.slice(0, o).join(", ") + r }, dictionary: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? " is " : arguments[1], r = arguments.length <= 2 || void 0 === arguments[2] ? ", " : arguments[2], i = ""; if (t(n) && "object" === ("undefined" == typeof n ? "undefined" : _typeof(n)) && !o(n)) { var a = []; for (var u in n) if (n.hasOwnProperty(u)) { var l = n[u]; a.push("" + u + e + l) } return a.join(r) } return i }, frequency: function (n, e) { if (!o(n)) return null; var t = n.length, r = a.times(t); return 0 === t ? r + " " + e : e + " " + r }, pace: function (e, t) { var r = arguments.length <= 2 || void 0 === arguments[2] ? "time" : arguments[2]; if (0 === e || 0 === t) return "No " + a.pluralize(0, r); for (var i = "Approximately", o = void 0, u = void 0, l = e / t, f = 0; f < n.length; ++f) { var c = n[f]; if (u = l * c.value, u > 1) { o = c.name; break } } o || (i = "Less than", u = 1, o = n[n.length - 1].name); var v = Math.round(u); return r = a.pluralize(v, r), i + " " + v + " " + r + " per " + o }, nl2br: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? "<br/>" : arguments[1]; return n.replace(/\n/g, e) }, br2nl: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? "\r\n" : arguments[1]; return n.replace(/\<br\s*\/?\>/g, e) }, capitalize: function (n) { var e = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1]; return "" + n.charAt(0).toUpperCase() + (e ? n.slice(1).toLowerCase() : n.slice(1)) }, capitalizeAll: function (n) { return n.replace(/(?:^|\s)\S/g, function (n) { return n.toUpperCase() }) }, titleCase: function (n) { var e = /\b(a|an|and|at|but|by|de|en|for|if|in|of|on|or|the|to|via|vs?\.?)\b/i, t = /\S+[A-Z]+\S*/, r = /\s+/, i = /-/, o = void 0; return (o = function (n) { for (var u = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1], l = arguments.length <= 2 || void 0 === arguments[2] ? !0 : arguments[2], f = [], c = n.split(u ? i : r), v = 0; v < c.length; ++v) { var s = c[v]; -1 === s.indexOf("-") ? !l || 0 !== v && v !== c.length - 1 ? t.test(s) ? f.push(s) : e.test(s) ? f.push(s.toLowerCase()) : f.push(a.capitalize(s)) : f.push(t.test(s) ? s : a.capitalize(s)) : f.push(o(s, !0, 0 === v || v === c.length - 1)) } return f.join(u ? "-" : " ") })(n) }, titlecase: function () { return a.titleCase.apply(a, arguments) } }; return a });</script>
    <script>/* morphdom.min.js */ "use strict"; function morphAttrs(n, t) { var c = t.attributes, r, i, u, f, e, o, h, s; if (t.nodeType !== DOCUMENT_FRAGMENT_NODE && n.nodeType !== DOCUMENT_FRAGMENT_NODE) { for (o = c.length - 1; o >= 0; o--)r = c[o], i = r.name, u = r.namespaceURI, f = r.value, u ? (i = r.localName || i, e = n.getAttributeNS(u, i), e !== f && (r.prefix === "xmlns" && (i = r.name), n.setAttributeNS(u, i, f))) : (e = n.getAttribute(i), e !== f && n.setAttribute(i, f)); for (h = n.attributes, s = h.length - 1; s >= 0; s--)r = h[s], i = r.name, u = r.namespaceURI, u ? (i = r.localName || i, t.hasAttributeNS(u, i) || n.removeAttributeNS(u, i)) : t.hasAttribute(i) || n.removeAttribute(i) } } function createFragmentFromTemplate(n) { var t = doc.createElement("template"); return t.innerHTML = n, t.content.childNodes[0] } function createFragmentFromRange(n) { range || (range = doc.createRange(), range.selectNode(doc.body)); var t = range.createContextualFragment(n); return t.childNodes[0] } function createFragmentFromWrap(n) { var t = doc.createElement("body"); return t.innerHTML = n, t.childNodes[0] } function toElement(n) { return (n = n.trim(), HAS_TEMPLATE_SUPPORT) ? createFragmentFromTemplate(n) : HAS_RANGE_SUPPORT ? createFragmentFromRange(n) : createFragmentFromWrap(n) } function compareNodeNames(n, t) { var i = n.nodeName, r = t.nodeName, u, f; return i === r ? !0 : (u = i.charCodeAt(0), f = r.charCodeAt(0), u <= 90 && f >= 97 ? i === r.toUpperCase() : f <= 90 && u >= 97 ? r === i.toUpperCase() : !1) } function createElementNS(n, t) { return !t || t === NS_XHTML ? doc.createElement(n) : doc.createElementNS(t, n) } function moveChildren(n, t) { for (var i = n.firstChild, r; i;)r = i.nextSibling, t.appendChild(i), i = r; return t } function syncBooleanAttrProp(n, t, i) { n[i] !== t[i] && (n[i] = t[i], n[i] ? n.setAttribute(i, "") : n.removeAttribute(i)) } function noop() { } function defaultGetNodeKey(n) { if (n) return n.getAttribute && n.getAttribute("id") || n.id } function morphdomFactory(n) { return function (t, i, r) { function h(n) { s.push(n) } function d(n, t) { var i, r; if (n.nodeType === ELEMENT_NODE) for (i = n.firstChild; i;)r = undefined, t && (r = f(i)) ? h(r) : (o(i), i.firstChild && d(i, t)), i = i.nextSibling } function c(n, t, i) { et(n) !== !1 && (t && t.removeChild(n), o(n), d(n, i)) } function g(n) { var t, i; if (n.nodeType === ELEMENT_NODE || n.nodeType === DOCUMENT_FRAGMENT_NODE$1) for (t = n.firstChild; t;)i = f(t), i && (e[i] = t), g(t), t = t.nextSibling } function w(n) { var t, u, r, i; for (rt(n), t = n.firstChild; t;)u = t.nextSibling, r = f(t), r ? (i = e[r], i && compareNodeNames(t, i) ? (t.parentNode.replaceChild(i, t), l(i, t)) : w(t)) : w(t), t = u } function ht(n, t, i) { while (t) { var r = t.nextSibling; (i = f(t)) ? h(i) : c(t, n, !0); t = r } } function l(t, i, r) { var u = f(i); if (u && delete e[u], !r) { if (ut(t, i) === !1) return; if (n(t, i), ft(t), ot(t, i) === !1) return } t.nodeName !== "TEXTAREA" ? ct(t, i) : specialElHandlers.TEXTAREA(t, i) } function ct(n, t) { var g = st(n, t), i = t.firstChild, r = n.firstChild, a, o, v, p, s, y, u, b, d; n: while (i) { for (p = i.nextSibling, a = f(i); !g && r;) { if (v = r.nextSibling, i.isSameNode && i.isSameNode(r)) { i = p; r = v; continue n } if (o = f(r), y = r.nodeType, u = undefined, y === i.nodeType && (y === ELEMENT_NODE ? (a ? a !== o && ((s = e[a]) ? v === s ? u = !1 : (n.insertBefore(s, r), o ? h(o) : c(r, n, !0), r = s) : u = !1) : o && (u = !1), u = u !== !1 && compareNodeNames(r, i), u && l(r, i)) : (y === TEXT_NODE || y == COMMENT_NODE) && (u = !0, r.nodeValue !== i.nodeValue && (r.nodeValue = i.nodeValue))), u) { i = p; r = v; continue n } o ? h(o) : c(r, n, !0); r = v } a && (s = e[a]) && compareNodeNames(s, i) ? (g || k(n, s), l(s, i)) : (b = it(i), b !== !1 && (b && (i = b), i.actualize && (i = i.actualize(n.ownerDocument || doc)), k(n, i), w(i))); i = p; r = v } ht(n, r, o); d = specialElHandlers[n.nodeName]; d && d(n, t) } var b, v, tt, y; r || (r = {}); typeof i == "string" ? t.nodeName === "#document" || t.nodeName === "HTML" || t.nodeName === "BODY" ? (b = i, i = doc.createElement("html"), i.innerHTML = b) : i = toElement(i) : i.nodeType === DOCUMENT_FRAGMENT_NODE$1 && (i = i.firstElementChild); var f = r.getNodeKey || defaultGetNodeKey, it = r.onBeforeNodeAdded || noop, rt = r.onNodeAdded || noop, ut = r.onBeforeElUpdated || noop, ft = r.onElUpdated || noop, et = r.onBeforeNodeDiscarded || noop, o = r.onNodeDiscarded || noop, ot = r.onBeforeElChildrenUpdated || noop, st = r.skipFromChildren || noop, k = r.addChild || function (n, t) { return n.appendChild(t) }, p = r.childrenOnly === !0, e = Object.create(null), s = []; g(t); var u = t, a = u.nodeType, nt = i.nodeType; if (!p) if (a === ELEMENT_NODE) nt === ELEMENT_NODE ? compareNodeNames(t, i) || (o(t), u = moveChildren(t, createElementNS(i.nodeName, i.namespaceURI))) : u = i; else if (a === TEXT_NODE || a === COMMENT_NODE) { if (nt === a) return u.nodeValue !== i.nodeValue && (u.nodeValue = i.nodeValue), u; u = i } if (u === i) o(t); else { if (i.isSameNode && i.isSameNode(u)) return; if (l(u, i, p), s) for (v = 0, tt = s.length; v < tt; v++)y = e[s[v]], y && c(y, y.parentNode, !1) } return !p && u !== t && t.parentNode && (u.actualize && (u = u.actualize(t.ownerDocument || doc)), t.parentNode.replaceChild(u, t)), u } } var DOCUMENT_FRAGMENT_NODE = 11, range, NS_XHTML = "http://www.w3.org/1999/xhtml", doc = typeof document == "undefined" ? undefined : document, HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template"), HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange(), specialElHandlers = { OPTION: function (n, t) { var i = n.parentNode, r; i && (r = i.nodeName.toUpperCase(), r === "OPTGROUP" && (i = i.parentNode, r = i && i.nodeName.toUpperCase()), r !== "SELECT" || i.hasAttribute("multiple") || (n.hasAttribute("selected") && !t.selected && (n.setAttribute("selected", "selected"), n.removeAttribute("selected")), i.selectedIndex = -1)); syncBooleanAttrProp(n, t, "selected") }, INPUT: function (n, t) { syncBooleanAttrProp(n, t, "checked"); syncBooleanAttrProp(n, t, "disabled"); n.value !== t.value && (n.value = t.value); t.hasAttribute("value") || n.removeAttribute("value") }, TEXTAREA: function (n, t) { var i = t.value, r, u; if (n.value !== i && (n.value = i), r = n.firstChild, r) { if (u = r.nodeValue, u == i || !i && u == n.placeholder) return; r.nodeValue = i } }, SELECT: function (n, t) { if (!t.hasAttribute("multiple")) { for (var f = -1, e = 0, i = n.firstChild, r, u; i;)if (u = i.nodeName && i.nodeName.toUpperCase(), u === "OPTGROUP") r = i, i = r.firstChild; else { if (u === "OPTION") { if (i.hasAttribute("selected")) { f = e; break } e++ } i = i.nextSibling; !i && r && (i = r.nextSibling, r = null) } n.selectedIndex = f } } }, ELEMENT_NODE = 1, DOCUMENT_FRAGMENT_NODE$1 = 11, TEXT_NODE = 3, COMMENT_NODE = 8, morphdom = morphdomFactory(morphAttrs); module.exports = morphdom;</script>
</head>
<body>
    <header>
        <nav>
            <a href="" class="active">⌂ torrentkontrol</a>
        </nav>
    </header>
    <main>
        <section style="grid-template-columns: 1fr 1fr; gap: 0;">
            <button onclick='addtorrent()'>add through magnet link</button>
            <button onclick='addtorrent()' disabled>add through torrent file [not yet supported]</button>
        </section>
        <section>
            <ul id="links" style="grid-template-columns: repeat(auto-fit, minmax(10rem, 1fr))"></ul>
        </section>
        <section>
            <ul id="torrents">
                <li>no torrents active</li>
            </ul>
        </section>
        <section>
            <ul id="files"></ul>
        </section>
    </main>
    <footer>
        <p>&copy; 2023</p>
        <p>written by <a href="https://davepermen.net">davepermen</a></p>
        <p>a <a href="https://conesoft.net">conesoft product</a> running on .NET 7</p>
    </footer>
    <script>
        const sleep = (delay, resolveValue) => new Promise((resolve) => {
            setTimeout(() => resolve(resolveValue), delay)
        })

        async function addmagnethandler() {
            try {
                await navigator.registerProtocolHandler('magnet', document.location.origin + '/addmagneturi?uri=%s', 'TorrentKontrol magnet:// linkhandler');
            } catch (e) {
                console.log('can\'t register magnet://')
            }
        }
        addmagnethandler()

        async function addtorrenthandler() {
            try {
                launchQueue.setConsumer(async parameters => {
                    for (const handle in parameters.files) {
                        const file = await handle.getFile()
                        await fetch('/addtorrentfile', { method: 'POST', body: file })
                    }
                });
            } catch (e) {
                console.log('can\'t register .torrent')
            }
        }
        addtorrenthandler()

        async function addtorrent() {
            await fetch('/addtorrent', {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'magnet': prompt('magnet link') })
            })
        }

        async function removetorrent(hash) {
            await fetch('/removetorrent', {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'hash': hash })
            })
        }

        async function updateList(id, mapping) {
            console.log('updating list ' + id)
            let list = await (await fetch('/' + id)).json()
            let html = list.map(mapping).map(entry => entry !== null ? '<li horizontal style="grid-template-columns: 1fr auto">' + entry + '</li>' : '').join('\n')
            var item = document.getElementById(id)
            if (html !== item.innerHTML) {
                var copy = item.cloneNode().outerHTML
                var startTag = copy.split('>')[0] + '>'
                var endTag = copy.slice(startTag.length)
                try {
                    morphdom(item, startTag + html + endTag)
                } catch {
                    item.innerHTML = html
                }
            }
        }

        async function updateTable(id, mapping) {
            let list = await (await fetch('/' + id)).json()
            let html = list.map(mapping).map(entry => entry !== null ? '<tr>' + entry + '</tr>' : '').join('\n')
            var item = document.getElementById(id)
            if (html !== item.innerHTML) {
                var copy = item.cloneNode().outerHTML
                var startTag = copy.split('>')[0] + '>'
                var endTag = copy.slice(startTag.length)
                console.log("starttag: " + startTag)
                console.log("endtag: " + endTag)
                morphdom(item, startTag + html + endTag)
            }
        }

        async function loop() {
            while (true) {
                let requests = [
                    updateList('torrents', torrent =>
                        (torrent.state.toLowerCase() !== 'stopping' && torrent.state.toLowerCase() !== 'stopped')
                            ?
                            `<section vertical>
                                                        <b>${torrent.name}</b>
                                                            ${(torrent.size == -1
                                ? `<aside>incoming transmission ...</aside>`
                                : `<aside>size: ${Humanize.fileSize(torrent.size)}, ${torrent.progress.toFixed(2)}%, speed: ${Humanize.fileSize(torrent.downloadSpeed)}/s ${torrent.state.toLowerCase()}</aside>
                                                           <progress max='100' value=${torrent.progress}></progress>`
                            )}
                                                    </section>
                                                    <button onclick='removetorrent("${torrent.hash}")'>✕</button>`
                            : null
                    ),

                    updateList('files', file => `<a href='https://files.conesoft.net/Downloads/Torrents/${file.fullname + file.extension}' target='_blank'>${file.name}</a><td green>${Humanize.fileSize(file.size)}</td>`),
                    updateList('links', link => '<a href="https://' + link.url + '" target="_blank">' + link.name + '</a>'),

                    sleep(333)
                ]
                await Promise.all(requests)
            }
        }

        loop()
    </script>
</body>
</html>